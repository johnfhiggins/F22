using Parameters, CSV, DataFrames

@with_kw struct Primitives 
    sim_data :: DataFrame = DataFrame(CSV.File("PS4_simdata.csv")) 
    state_space :: DataFrame = DataFrame(CSV.File("PS4_state_space.csv")) 
    trans_a0 :: DataFrame = DataFrame(CSV.File("PS4_transition_a0.csv")) 
    trans_a1 :: DataFrame = DataFrame(CSV.File("PS4_transition_a1.csv")) 
    #vector of consumption shocks
    c_grid :: Vector{Float64} = [0, 1]
    #probability of each consumption shock
    c_prob :: Vector{Float64} = [0.5, 0.5]
    #normal price
    p_r :: Float64 = 4
    #sale price 
    p_s :: Float64 = 1
    #price vector
    p_grid :: Vector{Float64} = [p_r, p_s] 
    #transition matrix for prices
    Π :: Array{Float64,2} = [0.75 0.25; 0.9 0.1]
    #stockout penalty
    λ :: Float64 = -4
    c :: Float64 = 2
    #capacity constraint
    ibar :: Float64 = 8
    #discount factor
    β :: Float64 = 0.99 
    #matrix to keep track of which variables correspond to which state
    S :: Array{Float64, 2} = S_maker(length(p_grid), length(c_grid), ibar + 1)
end

mutable struct Results
    #expected value function
    v_bar :: Array{Float64,3}
    #implied expected value function using CCP
    v_bar_p :: Array{Float64, 3}
    #policy function
    pol_func :: Array{Float64, 3}
    #conditional choice probability 
    p_hat :: Array{Float64, 3}
end

function S_maker(np, nc, ni)
    S = zeros(36, 3)
    n=0
    for p =1:np, c=1:nc, i=1:ni
        n +=1
        S[n,:] = [i, p, c]
    end
    S
end


function bellman(prim::Primitives, res::Results)
    @unpack c_grid, c_prob, p_grid, Π, λ, c, trans_a0, trans_a1, S = prim
    K = length(c_grid)*length(p_grid)*(ibar+1)
    for k=1:K
        i, p_i, c_i = S[k,:]
        
    end
end
